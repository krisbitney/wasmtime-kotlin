package eth.krisbitney.wasmtime

import eth.krisbitney.wasmtime.wasm.ErrorFrame
import kotlinx.cinterop.*
import wasmtime.*

/**
 * Represents a Wasmtime error, which is an error generated by the Wasmtime runtime during execution.
 *
 * @property message The error message as a string.
 * @property exitStatus The WASI-specific exit status if the error is a WASI "exit" trap, or `null` if the error is not a WASI exit trap.
 * @property wasmTrace A list of [ErrorFrame] instances representing the WebAssembly stack trace associated with the error.
 *
 * @constructor Constructs a new [WasmtimeException] from the given [wasmtime_error_t] pointer.
 * @param error The C pointer to a [wasmtime_error_t] struct.
 * @param ownedByCaller If `true`, the [error] pointer is owned by the caller and will not be deleted by this class.
 */
class WasmtimeException(private val error: CPointer<wasmtime_error_t>, ownedByCaller: Boolean = false) : Throwable() {

    val exitStatus: Int? = memScoped {
        val status = alloc<IntVar>()
        if (wasmtime_error_exit_status(error, status.ptr)) {
            status.value
        } else {
            null
        }
    }

    val wasmTrace: List<ErrorFrame> = memScoped {
        val frameVec = alloc<wasm_frame_vec_t>()
        wasmtime_error_wasm_trace(error, frameVec.ptr)

        val frames = List(frameVec.size.toInt()) { index ->
            ErrorFrame(frameVec.data?.get(index)!!)
        }

        frames
    }

    override val message: String = memScoped {
        val msg = alloc<wasm_name_t>()
        wasmtime_error_message(error, msg.ptr)
        var result = msg.data?.toKString() ?: ""
        exitStatus?.let { result += " (exit status: $it)" }
        wasmTrace.forEach { frame -> result += "\n    $frame" }
        result
    }

    init {
        if (!ownedByCaller) {
            wasmtime_error_delete(error)
        }
    }
}